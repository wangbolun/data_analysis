"""LCM type definitions
This file automatically generated by lcm.
DO NOT MODIFY BY HAND!!!!
"""

try:
    import cStringIO.StringIO as BytesIO
except ImportError:
    from io import BytesIO
import struct

class phantomvision_object_t(object):
    __slots__ = ["id", "valid", "measured", "classification", "view_face", "lane_assignment", "brake_light", "flash_light", "turn_signal", "object_confidence", "num_class_candidates", "classification_candidates", "num_class_confidences", "classification_confidences", "position_x_m", "position_y_m", "rel_velocity_x_mps", "rel_velocity_y_mps", "rel_accel_x_mps2", "rel_accel_y_mps2", "range_velocity_mps", "range_m", "angle_rads", "width_m", "length_m", "height_m", "orientation_rads", "total_left_bounding_angle_valid", "total_right_bounding_angle_valid", "total_left_bounding_angle_rads", "total_right_bounding_angle_rads", "face_left_bounding_angle_valid", "face_right_bounding_angle_valid", "face_left_bounding_angle_rads", "face_right_bounding_angle_rads", "age_secs", "time_to_collision_secs", "cipv", "oncoming_traffic", "cross_traffic", "num_extra_values", "extra_values", "num_extra_infos", "extra_infos", "camera_id"]

    CLASSIFICATION_UNKNOWN = 0
    CLASSIFICATION_CAR = 1
    CLASSIFICATION_TRUCK = 2
    CLASSIFICATION_MOTORCYCLE = 3
    CLASSIFICATION_PEDESTRIAN = 4
    CLASSIFICATION_OTHER = 5
    CLASSIFICATION_WHEEL = 6
    CLASSIFICATION_CART = 7
    CLASSIFICATION_SEDAN = 10
    CLASSIFICATION_SUV = 11
    CLASSIFICATION_VAN = 12
    CLASSIFICATION_TRAILER = 13
    CLASSIFICATION_BUS = 14
    CLASSIFICATION_GLARE = 15
    CLASSIFICATION_GENERAL = 16
    CLASSIFICATION_STOPPER = 8
    CLASSIFICATION_POLE = 9
    CLASSIFICATION_BICYCLE = 17
    CLASSIFICATION_BICYCLIST = 18
    CLASSIFICATION_MOTORCYCLIST = 19
    CLASSIFICATION_TRAFFIC_CONE = 20
    CLASSIFICATION_TRAFFIC_SIGN = 21
    CLASSIFICATION_TRAFFIC_SPEED = 22
    CLASSIFICATION_TRAFFIC_STOP = 23
    CLASSIFICATION_TRAFFIC_YIELD = 24
    CLASSIFICATION_TRAFFIC_CONSTRUCTION = 25
    CLASSIFICATION_TRAFFIC_LIGHT = 26
    VIEW_FACE_UNKNOWN = 0
    VIEW_FACE_WHOLE = 1
    VIEW_FACE_FRONT = 2
    VIEW_FACE_REAR = 3
    VIEW_FACE_SIDE = 4
    VIEW_FACE_FRONT_LEFT = 5
    VIEW_FACE_FRONT_RIGHT = 6
    VIEW_FACE_REAR_LEFT = 7
    VIEW_FACE_REAR_RIGHT = 8
    VIEW_FACE_SIDE_FRONT = 9
    VIEW_FACE_SIDE_REAR = 10
    LANE_ASSIGNMENT_UNKNOWN = 127
    LANE_ASSIGNMENT_CENTER = 0
    LANE_ASSIGNMENT_LEFT = 1
    LANE_ASSIGNMENT_RIGHT = -1
    LANE_ASSIGNMENT_NEXT_LEFT = 2
    LANE_ASSIGNMENT_NEXT_RIGHT = -2
    LANE_ASSIGNMENT_FAR_LEFT = 3
    LANE_ASSIGNMENT_FAR_RIGHT = -3
    BRAKE_LIGHT_UNKNOWN = 0
    BRAKE_LIGHT_OFF = 1
    BRAKE_LIGHT_ON = 2
    FLASH_LIGHT_UNKNOWN = 0
    FLASH_LIGHT_OFF = 1
    FLASH_LIGHT_ON = 2
    FLASH_LIGHT_BLINK = 3
    TURN_SIGNAL_UNKNOWN = 0
    TURN_SIGNAL_OFF = 1
    TURN_SIGNAL_LEFT = 2
    TURN_SIGNAL_RIGHT = 3
    TURN_SIGNAL_BOTH = 4
    OBJECT_CONFIDENCE_UNKNOWN = 0
    OBJECT_CONFIDENCE_LOW = 1
    OBJECT_CONFIDENCE_MID = 2
    OBJECT_CONFIDENCE_HIGH = 3
    CAM_FRONT_CENTER = 0
    CAM_FRONT_CENTER_CROP = 1
    CAM_FRONT_CENTER_SVM = 4
    CAM_REAR_CENTER_SVM = 15
    CAM_SIDE_LEFT = 17
    CAM_SIDE_RIGHT = 18

    def __init__(self):
        self.id = 0
        self.valid = False
        self.measured = False
        self.classification = 0
        self.view_face = 0
        self.lane_assignment = 0
        self.brake_light = 0
        self.flash_light = 0
        self.turn_signal = 0
        self.object_confidence = 0
        self.num_class_candidates = 0
        self.classification_candidates = []
        self.num_class_confidences = 0
        self.classification_confidences = []
        self.position_x_m = 0.0
        self.position_y_m = 0.0
        self.rel_velocity_x_mps = 0.0
        self.rel_velocity_y_mps = 0.0
        self.rel_accel_x_mps2 = 0.0
        self.rel_accel_y_mps2 = 0.0
        self.range_velocity_mps = 0.0
        self.range_m = 0.0
        self.angle_rads = 0.0
        self.width_m = 0.0
        self.length_m = 0.0
        self.height_m = 0.0
        self.orientation_rads = 0.0
        self.total_left_bounding_angle_valid = False
        self.total_right_bounding_angle_valid = False
        self.total_left_bounding_angle_rads = 0.0
        self.total_right_bounding_angle_rads = 0.0
        self.face_left_bounding_angle_valid = False
        self.face_right_bounding_angle_valid = False
        self.face_left_bounding_angle_rads = 0.0
        self.face_right_bounding_angle_rads = 0.0
        self.age_secs = 0.0
        self.time_to_collision_secs = 0.0
        self.cipv = False
        self.oncoming_traffic = False
        self.cross_traffic = False
        self.num_extra_values = 0
        self.extra_values = []
        self.num_extra_infos = 0
        self.extra_infos = []
        self.camera_id = 0

    def encode(self):
        buf = BytesIO()
        buf.write(phantomvision_object_t._get_packed_fingerprint())
        self._encode_one(buf)
        return buf.getvalue()

    def _encode_one(self, buf):
        buf.write(struct.pack(">ibbbbbbbbbi", self.id, self.valid, self.measured, self.classification, self.view_face, self.lane_assignment, self.brake_light, self.flash_light, self.turn_signal, self.object_confidence, self.num_class_candidates))
        buf.write(struct.pack('>%db' % self.num_class_candidates, *self.classification_candidates[:self.num_class_candidates]))
        buf.write(struct.pack(">i", self.num_class_confidences))
        buf.write(struct.pack('>%df' % self.num_class_confidences, *self.classification_confidences[:self.num_class_confidences]))
        buf.write(struct.pack(">fffffffffffffbbffbbffffbbbi", self.position_x_m, self.position_y_m, self.rel_velocity_x_mps, self.rel_velocity_y_mps, self.rel_accel_x_mps2, self.rel_accel_y_mps2, self.range_velocity_mps, self.range_m, self.angle_rads, self.width_m, self.length_m, self.height_m, self.orientation_rads, self.total_left_bounding_angle_valid, self.total_right_bounding_angle_valid, self.total_left_bounding_angle_rads, self.total_right_bounding_angle_rads, self.face_left_bounding_angle_valid, self.face_right_bounding_angle_valid, self.face_left_bounding_angle_rads, self.face_right_bounding_angle_rads, self.age_secs, self.time_to_collision_secs, self.cipv, self.oncoming_traffic, self.cross_traffic, self.num_extra_values))
        buf.write(struct.pack('>%df' % self.num_extra_values, *self.extra_values[:self.num_extra_values]))
        buf.write(struct.pack(">i", self.num_extra_infos))
        for i0 in range(self.num_extra_infos):
            __extra_infos_encoded = self.extra_infos[i0].encode('utf-8')
            buf.write(struct.pack('>I', len(__extra_infos_encoded)+1))
            buf.write(__extra_infos_encoded)
            buf.write(b"\0")
        buf.write(struct.pack(">b", self.camera_id))

    def decode(data):
        if hasattr(data, 'read'):
            buf = data
        else:
            buf = BytesIO(data)
        if buf.read(8) != phantomvision_object_t._get_packed_fingerprint():
            raise ValueError("Decode error")
        return phantomvision_object_t._decode_one(buf)
    decode = staticmethod(decode)

    def _decode_one(buf):
        self = phantomvision_object_t()
        self.id = struct.unpack(">i", buf.read(4))[0]
        self.valid = bool(struct.unpack('b', buf.read(1))[0])
        self.measured = bool(struct.unpack('b', buf.read(1))[0])
        self.classification, self.view_face, self.lane_assignment, self.brake_light, self.flash_light, self.turn_signal, self.object_confidence, self.num_class_candidates = struct.unpack(">bbbbbbbi", buf.read(11))
        self.classification_candidates = struct.unpack('>%db' % self.num_class_candidates, buf.read(self.num_class_candidates))
        self.num_class_confidences = struct.unpack(">i", buf.read(4))[0]
        self.classification_confidences = struct.unpack('>%df' % self.num_class_confidences, buf.read(self.num_class_confidences * 4))
        self.position_x_m, self.position_y_m, self.rel_velocity_x_mps, self.rel_velocity_y_mps, self.rel_accel_x_mps2, self.rel_accel_y_mps2, self.range_velocity_mps, self.range_m, self.angle_rads, self.width_m, self.length_m, self.height_m, self.orientation_rads = struct.unpack(">fffffffffffff", buf.read(52))
        self.total_left_bounding_angle_valid = bool(struct.unpack('b', buf.read(1))[0])
        self.total_right_bounding_angle_valid = bool(struct.unpack('b', buf.read(1))[0])
        self.total_left_bounding_angle_rads, self.total_right_bounding_angle_rads = struct.unpack(">ff", buf.read(8))
        self.face_left_bounding_angle_valid = bool(struct.unpack('b', buf.read(1))[0])
        self.face_right_bounding_angle_valid = bool(struct.unpack('b', buf.read(1))[0])
        self.face_left_bounding_angle_rads, self.face_right_bounding_angle_rads, self.age_secs, self.time_to_collision_secs = struct.unpack(">ffff", buf.read(16))
        self.cipv = bool(struct.unpack('b', buf.read(1))[0])
        self.oncoming_traffic = bool(struct.unpack('b', buf.read(1))[0])
        self.cross_traffic = bool(struct.unpack('b', buf.read(1))[0])
        self.num_extra_values = struct.unpack(">i", buf.read(4))[0]
        self.extra_values = struct.unpack('>%df' % self.num_extra_values, buf.read(self.num_extra_values * 4))
        self.num_extra_infos = struct.unpack(">i", buf.read(4))[0]
        self.extra_infos = []
        for i0 in range(self.num_extra_infos):
            __extra_infos_len = struct.unpack('>I', buf.read(4))[0]
            self.extra_infos.append(buf.read(__extra_infos_len)[:-1].decode('utf-8', 'replace'))
        self.camera_id = struct.unpack(">b", buf.read(1))[0]
        return self
    _decode_one = staticmethod(_decode_one)

    _hash = None
    def _get_hash_recursive(parents):
        if phantomvision_object_t in parents: return 0
        tmphash = (0x13c0f12977dcf7a) & 0xffffffffffffffff
        tmphash  = (((tmphash<<1)&0xffffffffffffffff)  + (tmphash>>63)) & 0xffffffffffffffff
        return tmphash
    _get_hash_recursive = staticmethod(_get_hash_recursive)
    _packed_fingerprint = None

    def _get_packed_fingerprint():
        if phantomvision_object_t._packed_fingerprint is None:
            phantomvision_object_t._packed_fingerprint = struct.pack(">Q", phantomvision_object_t._get_hash_recursive([]))
        return phantomvision_object_t._packed_fingerprint
    _get_packed_fingerprint = staticmethod(_get_packed_fingerprint)

